/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.github.jershell.kbson

import com.github.jershell.kbson.models.Blob
import com.github.jershell.kbson.models.ChildEntity
import com.github.jershell.kbson.models.Complex
import com.github.jershell.kbson.models.Custom
import com.github.jershell.kbson.models.EnumFoo
import com.github.jershell.kbson.models.Foo
import com.github.jershell.kbson.models.KeyByEnum
import com.github.jershell.kbson.models.Nested
import com.github.jershell.kbson.models.NestedComplex
import com.github.jershell.kbson.models.NestedMap
import com.github.jershell.kbson.models.NullableClass
import com.github.jershell.kbson.models.NullableCollection
import com.github.jershell.kbson.models.NullableDefaultClass
import com.github.jershell.kbson.models.NullableNotOptionalClass
import com.github.jershell.kbson.models.OptionalClass
import com.github.jershell.kbson.models.SEX
import com.github.jershell.kbson.models.SexWithValue
import com.github.jershell.kbson.models.Simple
import com.github.jershell.kbson.models.SimpleNG
import com.github.jershell.kbson.models.Value
import com.github.jershell.kbson.models.WithPair
import com.github.jershell.kbson.models.WithUUID
import com.github.jershell.kbson.models.WrapperMapWithAdvancedKey
import com.github.jershell.kbson.models.WrapperMapWithObjectId
import com.github.jershell.kbson.models.WrapperSet
import com.github.jershell.kbson.models.polymorph.FooTimestampedMessage
import com.github.jershell.kbson.models.polymorph.IntMessage
import com.github.jershell.kbson.models.polymorph.Message
import com.github.jershell.kbson.models.polymorph.MessageWrapper
import com.github.jershell.kbson.models.polymorph.SMessage
import com.github.jershell.kbson.models.polymorph.SealedWrapper
import com.github.jershell.kbson.models.polymorph.StringMessage
import com.github.jershell.kbson.models.polymorph.TimestampedMessage
import com.github.jershell.kbson.models.polymorph.Wrapper
import kotlinx.serialization.PolymorphicSerializer
import kotlinx.serialization.SerializationException
import kotlinx.serialization.modules.SerializersModule
import kotlinx.serialization.modules.plus
import kotlinx.serialization.modules.polymorphic
import kotlinx.serialization.modules.subclass
import org.bson.BsonArray
import org.bson.BsonBinary
import org.bson.BsonBoolean
import org.bson.BsonDateTime
import org.bson.BsonDecimal128
import org.bson.BsonDocument
import org.bson.BsonDouble
import org.bson.BsonInt32
import org.bson.BsonInt64
import org.bson.BsonInvalidOperationException
import org.bson.BsonNull
import org.bson.BsonObjectId
import org.bson.BsonString
import org.bson.BsonSymbol
import org.bson.UuidRepresentation
import org.bson.types.Decimal128
import org.bson.types.ObjectId
import java.math.BigDecimal
import java.time.Instant
import java.util.Arrays
import java.util.Date
import java.util.UUID
import kotlin.math.PI
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue


class KBsonTest {
    private val kBson = KBson()

    private val ts = 1562442284934L
    val img = this::class.java
        .getResource("/image.png")
        .readBytes()

    val txt = this::class.java.getResource("/lorem.txt").readBytes()
    val file = this::class.java.getResource("/MD5SUMS.zip").readBytes()

    // instance of data class
    val simpleModel = Simple(
        "value_string",
        PI,
        0.1f,
        42L,
        '€',
        true,
        42
    )
    val nestedModel = Nested(n = simpleModel, m = 42)
    val complexModel = Complex(
        Date(ts),
        Pair("FOO", "BAR"),
        listOf("foo", "bar", "baz"),
        Triple("foo", "bar", "baz"),
        mapOf("key_1" to 42, "key_2" to 24, "key_3" to 444),
        mapOf(true to "AAA", false to "BBB"),
        mapOf(2.45 to 222f, 22.11 to 333f)
    )

    val blobModel = Blob(img, txt, file)

    val blobDoc = BsonDocument().apply {
        put("img", BsonBinary(img))
        put("zipFile", BsonBinary(file))
        put("txt", BsonBinary(txt))
    }

    val strictBlobModel = Blob(
        img = img,
        txt = txt,
        zipFile = file
    )

    val strictBlobDoc = BsonDocument().apply {
        put("img", BsonBinary(img))
        put("txt", BsonBinary(txt))
        put("zipFile", BsonBinary(file))
    }

    val complexDoc = BsonDocument().apply {
        put("createAt", BsonDateTime(ts))
        put("pair", BsonDocument().apply {
            put("first", BsonString("FOO"))
            put("second", BsonString("BAR"))
        })
        put(
            "list", BsonArray(
                listOf(
                    BsonString("foo"),
                    BsonString("bar"),
                    BsonString("baz")
                )
            )
        )
        put("triple", BsonDocument().apply {
            put("first", BsonString("foo"))
            put("second", BsonString("bar"))
            put("third", BsonString("baz"))
        })
        put("map", BsonDocument().apply {
            put("key_1", BsonInt32(42))
            put("key_2", BsonInt32(24))
            put("key_3", BsonInt32(444))
        })
        put("booleanMap", BsonDocument().apply {
            put("true", BsonString("AAA"))
            put("false", BsonString("BBB"))
        })
        put("doubleFloatMap", BsonDocument().apply {
            put("2.45", BsonDouble(222.0))
            put("22.11", BsonDouble(333.0))
        })
    }

    // source document in bson
    val simpleDoc = BsonDocument().apply {
        put("valueDouble", BsonDouble(PI))
        put("valueString", BsonString("value_string"))
        put("valueFloat", BsonDouble(0.1f.toDouble()))
        put("valueInt", BsonInt32(42))
        put("valueLong", BsonInt64(42L))
        put("valueChar", BsonSymbol('€'.toString()))
        put("valueBool", BsonBoolean(true))
    }

    val strictSimpleDoc = BsonDocument().apply {
        put("valueString", BsonString("value_string"))
        put("valueDouble", BsonDouble(PI))
        put("valueFloat", BsonDouble(0.1f.toDouble()))
        put("valueLong", BsonInt64(42L))
        put("valueChar", BsonSymbol('€'.toString()))
        put("valueBool", BsonBoolean(true))
        put("valueInt", BsonInt32(42))
    }

    val nestedDoc = BsonDocument().apply {
        put("m", BsonInt32(42))
        put("n", simpleDoc)
    }

    val strictNestedDoc = BsonDocument().apply {
        put("n", strictSimpleDoc)
        put("m", BsonInt32(42))
    }


    val nestedComplex = NestedComplex(
        mapOf(
            10.toByte() to mapOf(
                '€' to SimpleNG(87, listOf('‡', '↪', '@', '$')),
                '$' to SimpleNG(88, listOf('!', '?', '~', '='))
            ),
            11.toByte() to mapOf(
                '€' to SimpleNG(89, listOf('‡', '↪', '@', '$')),
                '$' to SimpleNG(90, listOf('!', '?', '~', '='))
            )
        ),
        listOf(
            mapOf(
                40 to listOf(31, 32, 33, 34, 35),
                41 to listOf(31, 32, 33, 34, 35)
            ),
            mapOf(
                40 to listOf(1, 3, 3, 4, 5),
                41 to listOf(31, 32, 33, 34, 35)
            ),
            mapOf(
                40 to listOf(0, 0, 1, 4, 5),
                41 to listOf(31, 32, 33, 34, 35)
            ),
            mapOf(
                40 to listOf(11, 31, 31, 41, 51),
                41 to listOf(31, 32, 33, 34, 35)
            ),
            mapOf(
                44 to listOf(1, 33, 33, 44, 55),
                41 to listOf(31, 32, 33, 34, 35)
            )
        )
    )

    val nestedComplexDoc = BsonDocument().apply {
        put("mapOfMaps", BsonDocument().apply {
            put("10", BsonDocument().apply {
                put("€", BsonDocument().apply {
                    put("short", BsonInt32(87))
                    put("list", BsonArray(listOf(BsonSymbol("‡"), BsonSymbol("↪"), BsonSymbol("@"), BsonSymbol("$"))))
                })
                put("$", BsonDocument().apply {
                    put("short", BsonInt32(88))
                    put("list", BsonArray(listOf(BsonSymbol("!"), BsonSymbol("?"), BsonSymbol("~"), BsonSymbol("="))))
                })
            })
            put("11", BsonDocument().apply {
                put("€", BsonDocument().apply {
                    put("short", BsonInt32(89))
                    put("list", BsonArray(listOf(BsonSymbol("‡"), BsonSymbol("↪"), BsonSymbol("@"), BsonSymbol("$"))))
                })
                put("$", BsonDocument().apply {
                    put("short", BsonInt32(90))
                    put("list", BsonArray(listOf(BsonSymbol("!"), BsonSymbol("?"), BsonSymbol("~"), BsonSymbol("="))))
                })
            })
        })

        put("listOfMaps", BsonArray(
            listOf(
                BsonDocument().apply {
                    put(
                        "40",
                        BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35)))
                    )
                    put(
                        "41",
                        BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35)))
                    )
                },
                BsonDocument().apply {
                    put(
                        "40",
                        BsonArray(listOf(BsonInt32(1), BsonInt32(3), BsonInt32(3), BsonInt32(4), BsonInt32(5)))
                    )
                    put(
                        "41",
                        BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35)))
                    )
                },
                BsonDocument().apply {
                    put(
                        "40",
                        BsonArray(listOf(BsonInt32(0), BsonInt32(0), BsonInt32(1), BsonInt32(4), BsonInt32(5)))
                    )
                    put(
                        "41",
                        BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35)))
                    )
                },
                BsonDocument().apply {
                    put(
                        "40",
                        BsonArray(listOf(BsonInt32(11), BsonInt32(31), BsonInt32(31), BsonInt32(41), BsonInt32(51)))
                    )
                    put(
                        "41",
                        BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35)))
                    )
                },
                BsonDocument().apply {
                    put(
                        "44",
                        BsonArray(listOf(BsonInt32(1), BsonInt32(33), BsonInt32(33), BsonInt32(44), BsonInt32(55)))
                    )
                    put(
                        "41",
                        BsonArray(listOf(BsonInt32(31), BsonInt32(32), BsonInt32(33), BsonInt32(34), BsonInt32(35)))
                    )
                }

            )))
    }

    @Test
    fun simpleDocStringify() {
        assertEquals(simpleDoc, kBson.stringify(Simple.serializer(), simpleModel))
    }

    @Test
    fun simpleDocParseTest() {
        assertEquals(simpleModel, kBson.parse(Simple.serializer(), simpleDoc))
    }

    @Test
    fun nestedParse() {
        val res = kBson.parse(Nested.serializer(), nestedDoc)
        assertEquals(nestedModel, res)
    }

    @Test
    fun nestedStringify() {
        val d = nestedDoc
        val res = kBson.stringify(Nested.serializer(), nestedModel)
        assertEquals(d, res)
    }

    @Test
    fun complexStringify() {
        val expected = complexDoc
        val actual = kBson.stringify(Complex.serializer(), complexModel)
        assertEquals(expected, actual)
    }

    @Test
    fun complexParse() {
        val result = kBson.parse(Complex.serializer(), complexDoc)
        assertEquals(complexModel, result)
    }

    @Test
    fun nestedComplex() {
        val result: NestedComplex = kBson.parse(
            NestedComplex.serializer(),
            nestedComplexDoc
        )
        assertEquals(nestedComplex, result)
    }

    @Test
    fun nestedComplexStringify() {
        val result = kBson.stringify(NestedComplex.serializer(), nestedComplex)
        assertEquals(nestedComplexDoc, result)
    }

    @Test
    fun nestedComplexStringifyAndParse() {
        val tmp = kBson.stringify(NestedComplex.serializer(), nestedComplex)
        val result: NestedComplex = kBson.parse(NestedComplex.serializer(), tmp)
        assertEquals(nestedComplex, result)
    }

    @Test
    fun customTypesStringify() {
        val custom = Custom(ObjectId("5d17ab793b4083d41f829821"), BigDecimal("3.14"))
        val actual = kBson.stringify(Custom.serializer(), custom)
        val expectedCustomDoc = BsonDocument().apply {
            put("_id", BsonObjectId(ObjectId("5d17ab793b4083d41f829821")))
            put("dec128", BsonDecimal128(Decimal128(BigDecimal("3.14"))))
        }
        assertEquals(
            expectedCustomDoc,
            actual
        )
    }

    @Test
    fun objectId() {
        val custom = Custom(dec128 = BigDecimal("3.14"))
        val actual = kBson.stringify(Custom.serializer(), custom)
        val expectedCustomDoc = BsonDocument().apply {
            put("dec128", BsonDecimal128(Decimal128(BigDecimal("3.14"))))
        }
        assertEquals(
            expectedCustomDoc,
            actual
        )
    }

    @Test
    fun pairStringify() {
        val wp = WithPair(
            Pair(null, "value"),
            Triple(
                42,
                null,
                2L
            )
        )
        val expected = BsonDocument().apply {
            put("pair", BsonDocument().apply {
                put("first", BsonNull())
                put("second", BsonString("value"))

            })
            put("triple", BsonDocument().apply {
                put("first", BsonInt32(42))
                put("second", BsonNull())
                put("third", BsonInt64(2L))
            })
        }
        val actual = kBson.stringify(WithPair.serializer(), wp)

        assertEquals(
            expected,
            actual
        )
    }

    @Test
    fun objectIdStringify() {
        val childEntity = ChildEntity(userId = "5d17ab793b4083d41f829821")
        childEntity.updatedAt = Date()
        val actual = kBson.stringify(ChildEntity.serializer(), childEntity)

        val expected = BsonDocument().apply {
            put("userId", BsonString("5d17ab793b4083d41f829821"))
            put("createdAt", BsonNull())
            put("updatedAt", BsonDateTime(childEntity.updatedAt!!.time))
        }

        assertEquals(
            expected,
            actual
        )
    }

    @Test
    fun customTypesParse() {
        val expectedCustom = Custom(ObjectId("5d17ab793b4083d41f829821"), BigDecimal("3.14"))

        val customBsonDoc = BsonDocument().apply {
            put("_id", BsonObjectId(ObjectId("5d17ab793b4083d41f829821")))
            put("dec128", BsonDecimal128(Decimal128(BigDecimal("3.14"))))
        }

        val actualCustom = kBson.parse(Custom.serializer(), customBsonDoc)

        assertEquals(
            expectedCustom,
            actualCustom
        )
    }

    @Test
    fun blobStringify() {
        assertEquals(
            kBson.stringify(Blob.serializer(), blobModel),
            blobDoc
        )
    }

    @Test
    fun blobParse() {
        val expectedResult = blobModel
        val result = kBson.parse(Blob.serializer(), blobDoc)
        assertTrue(
            Arrays.equals(expectedResult.img, result.img) &&
                    Arrays.equals(expectedResult.txt, result.txt) &&
                    Arrays.equals(expectedResult.zipFile, result.zipFile)
        )
    }

    @Test
    fun optionalParse() {
        val badDoc = BsonDocument().apply {
            put("reqString3", BsonString("reqString3"))
        }
        val result = kBson.parse(OptionalClass.serializer(), badDoc)
        assertTrue(
            (result.reqString == "default_value1") &&
                    (result.reqString3 == "reqString3")
        )
    }

    @Test
    fun optionalStringify() {
        val data = OptionalClass(reqString3 = "foo")

        val doc = BsonDocument().apply {
            put("reqString", BsonString("default_value1"))
            put("reqString3", BsonString("foo"))
        }
        val result = kBson.stringify(OptionalClass.serializer(), data)
        assertEquals(doc, result)
    }

    @Test
    fun exceptionsMissingValue() {
        val docBadType = BsonDocument()

        try {
            kBson.parse(SimpleNG.serializer(), docBadType)
        } catch (e: SerializationException) {
            assertTrue(e.message == "Field 'short' is required, but it was missing")
        }
    }

    @Test
    fun exceptionsBadType() {
        val docBadType = BsonDocument().apply {
            put("short", BsonString("127"))
        }

        try {
            kBson.parse(SimpleNG.serializer(), docBadType)
        } catch (e: BsonInvalidOperationException) {
            assertTrue(e.message == "readInt32 can only be called when CurrentBSONType is INT32, not when CurrentBSONType is STRING.")
        }
    }

    @Test
    fun nullParseTest() {
        val docNullableField = BsonDocument().apply {
            put("str", BsonNull())
        }
        val docField = BsonDocument().apply {
            put("str", BsonString("exist"))
        }

        val result1 = kBson.parse(NullableClass.serializer(), docNullableField)
        val result2 = kBson.parse(NullableClass.serializer(), docField)
        assertTrue(result1.str == null && result2.str == "exist")
    }

    @Test
    fun nonFieldParse() {
        val doc = BsonDocument()
        val value = NullableDefaultClass()
        assertEquals(value, kBson.parse(NullableDefaultClass.serializer(), doc))
    }

    @Test
    fun nullStringifyTest() {
        val docNullableField = BsonDocument().apply {
            put("str", BsonNull())
        }

        val modelNullableField = NullableClass(null)

        val docField = BsonDocument().apply {
            put("str", BsonString("exist"))
        }

        val modelField = NullableClass("exist")

        val result1 = kBson.stringify(NullableClass.serializer(), modelNullableField)
        val result2 = kBson.stringify(NullableClass.serializer(), modelField)

        assert(
            docNullableField.equals(result1) &&
                    docField.equals(result2)
        )
    }

    @Test
    fun maps() {
        val foo = Foo(
            key_A = mapOf("a" to "a", "b" to "b", "c" to "c", "d" to "d", "e" to "e"),
            key_B = mapOf("a" to "a", "b" to "b", "c" to "c", "d" to "d", "e" to "e")
        )

        val doc = BsonDocument().apply {
            put("key_A", BsonDocument().apply {
                put("a", BsonString("a"))
                put("b", BsonString("b"))
                put("c", BsonString("c"))
                put("d", BsonString("d"))
                put("e", BsonString("e"))
            })
            put("key_B", BsonDocument().apply {
                put("a", BsonString("a"))
                put("b", BsonString("b"))
                put("c", BsonString("c"))
                put("d", BsonString("d"))
                put("e", BsonString("e"))
            })
        }
        val result = kBson.parse(Foo.serializer(), doc)
        assertEquals(foo, result)
    }

    @Test
    fun enumStringify() {
        val model = EnumFoo(
            sex = SEX.FEMALE,
            sex2 = SexWithValue.TRANSGENDER
        )

        val result = kBson.stringify(EnumFoo.serializer(), model)

        assertEquals(BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("TRANSGENDER"))
        }, result)
    }

    @Test
    fun enumParse() {
        val model = EnumFoo(
            sex = SEX.FEMALE,
            sex2 = SexWithValue.TRANSGENDER
        )

        val doc = BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("TRANSGENDER"))
        }
        val result = kBson.parse(EnumFoo.serializer(), doc)
        assertEquals(result, model)
    }

    @Test
    fun enumParseException() {
        val doc = BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("AGENDER"))
        }

        try {
            kBson.parse(EnumFoo.serializer(), doc)
        } catch (e: SerializationException) {
            assertEquals("Enum has unknown value AGENDER", e.message)
        }
    }

    @Test
    fun mapValueParse() {
        val a = NestedMap(
            "AAA", mapOf(
                "key" to Value("val1", listOf("val2", "val3"))
            )
        )

        val b = BsonDocument().apply {
            append("name", BsonString("AAA"))
            append("map", BsonDocument().apply {
                append("key", BsonDocument().apply {
                    append("value1", BsonString("val1"))
                    append("value2", BsonArray().apply {
                        add(BsonString("val2"))
                        add(BsonString("val3"))
                    })
                })
            })
        }

        assertEquals(a, kBson.parse(NestedMap.serializer(), b))
    }

    @Test
    fun loadSimpleDoc() {
        val result = kBson.load(Simple.serializer(), strictSimpleDoc)
        assertEquals(simpleModel, result)
    }

    @Test
    fun loadNested() {
        val res = kBson.load(Nested.serializer(), strictNestedDoc)
        assertEquals(nestedModel, res)
    }

    @Test
    fun loadComplex() {
        val result = kBson.load(Complex.serializer(), complexDoc.toByteArray())
        assertEquals(complexModel, result)
    }

    @Test
    fun nestedComplexDumpAndLoad() {
        val tmp = kBson.dump(NestedComplex.serializer(), nestedComplex)
        val result: NestedComplex = kBson.load(NestedComplex.serializer(), tmp)
        assertEquals(nestedComplex, result)
    }

    @Test
    fun customTypesLoad() {
        val expectedCustom = Custom(ObjectId("5d17ab793b4083d41f829821"), BigDecimal("3.14"))

        val customBsonDoc = BsonDocument().apply {
            put("_id", BsonObjectId(ObjectId("5d17ab793b4083d41f829821")))
            put("dec128", BsonDecimal128(Decimal128(BigDecimal("3.14"))))
        }.toByteArray()

        val actualCustom = kBson.load(Custom.serializer(), customBsonDoc)

        assertEquals(
            expectedCustom,
            actualCustom
        )
    }

    @Test
    fun blobLoad() {
        val expectedResult = strictBlobModel
        val result = kBson.load(Blob.serializer(), strictBlobDoc.toByteArray())
        assertTrue(
            Arrays.equals(expectedResult.img, result.img) &&
                    Arrays.equals(expectedResult.txt, result.txt) &&
                    Arrays.equals(expectedResult.zipFile, result.zipFile)
        )
    }

    @Test
    fun optionalLoad() {
        val badDoc = BsonDocument().apply {
            put("reqString3", BsonString("reqString3"))
        }
        val result = kBson.load(OptionalClass.serializer(), badDoc)
        assertTrue(
            (result.reqString == "default_value1") &&
                    (result.reqString3 == "reqString3")
        )
    }

    @Test
    fun loadNullTest() {
        val docNullableField = BsonDocument().apply {
            put("str", BsonNull())
        }
        val docField = BsonDocument().apply {
            put("str", BsonString("exist"))
        }

        val result1 = kBson.load(NullableClass.serializer(), docNullableField)
        val result2 = kBson.load(NullableClass.serializer(), docField)
        assertTrue(result1.str == null && result2.str == "exist")
    }

    @Test
    fun loadNonField() {
        val doc = BsonDocument()
        val value = NullableDefaultClass()
        assertEquals(value, kBson.load(NullableDefaultClass.serializer(), doc))
    }

    @Test
    fun loadMaps() {
        val foo = Foo(
            key_A = mapOf("a" to "a", "b" to "b", "c" to "c", "d" to "d", "e" to "e"),
            key_B = mapOf("a" to "a", "b" to "b", "c" to "c", "d" to "d", "e" to "e")
        )

        val doc = BsonDocument().apply {
            put("key_A", BsonDocument().apply {
                put("a", BsonString("a"))
                put("b", BsonString("b"))
                put("c", BsonString("c"))
                put("d", BsonString("d"))
                put("e", BsonString("e"))
            })
            put("key_B", BsonDocument().apply {
                put("a", BsonString("a"))
                put("b", BsonString("b"))
                put("c", BsonString("c"))
                put("d", BsonString("d"))
                put("e", BsonString("e"))
            })
        }
        val result = kBson.load(Foo.serializer(), doc)
        assertEquals(foo, result)
    }

    @Test
    fun loadEnum() {
        val model = EnumFoo(
            sex = SEX.FEMALE,
            sex2 = SexWithValue.TRANSGENDER
        )

        val doc = BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("TRANSGENDER"))
        }
        val result = kBson.load(EnumFoo.serializer(), doc)
        assertEquals(result, model)
    }

    @Test
    fun loadEnumException() {
        val doc = BsonDocument().apply {
            put("sex", BsonString("FEMALE"))
            put("sex2", BsonString("AGENDER"))
        }

        try {
            kBson.load(EnumFoo.serializer(), doc.toByteArray())
        } catch (e: SerializationException) {
            assertEquals("Enum has unknown value AGENDER", e.message)
        }
    }

    @Test
    fun loadMapValue() {
        val a = NestedMap(
            "AAA", mapOf(
                "key" to Value("val1", listOf("val2", "val3"))
            )
        )

        val b = BsonDocument().apply {
            append("name", BsonString("AAA"))
            append("map", BsonDocument().apply {
                append("key", BsonDocument().apply {
                    append("value1", BsonString("val1"))
                    append("value2", BsonArray().apply {
                        add(BsonString("val2"))
                        add(BsonString("val3"))
                    })
                })
            })
        }

        assertEquals(a, kBson.load(NestedMap.serializer(), b))
    }

    @Test
    fun parseNullableNotOptionalProperties() {
        val bsonDocument = BsonDocument().apply {
            append("s", BsonString("s"))
        }
        assertEquals(
            NullableNotOptionalClass("s", null),
            kBson.parse(NullableNotOptionalClass.serializer(), bsonDocument)
        )
    }

    @Test
    fun parseNullableCollection() {
        val bsonDocument = BsonDocument().apply {
            append("fieldNull", BsonNull())
            append("list", BsonArray().apply {
                add(BsonString("v1"))
                add(BsonNull())
                add(BsonNull())
                add(BsonString("v4"))
            })
            append("map", BsonDocument().apply {
                append("k1", BsonNull())
                append("k2", BsonInt32(42))
                append("k3", BsonInt32(44))
            })
        }

        val collection = NullableCollection(
            null,
            listOf("v1", null, null, "v4"),
            mapOf(
                "k1" to null,
                "k2" to 42,
                "k3" to 44
            )
        )

        assertEquals(collection, kBson.parse(NullableCollection.serializer(), bsonDocument))
    }

    @Test
    fun loadNullableCollection() {
        val expected = BsonDocument().apply {
            append("fieldNull", BsonNull())
            append("list", BsonArray().apply {
                add(BsonString("v1"))
                add(BsonNull())
                add(BsonNull())
                add(BsonString("v4"))
            })
            append("map", BsonDocument().apply {
                append("k1", BsonNull())
                append("k2", BsonInt32(42))
                append("k3", BsonInt32(44))
            })
        }

        val collection = NullableCollection(
            null,
            listOf("v1", null, null, "v4"),
            mapOf("k1" to null, "k2" to 42, "k3" to 44)
        )

        assertEquals(collection, kBson.load(NullableCollection.serializer(), expected))
    }

    @Test
    fun loadBinNullableCollection() {
        val expected = BsonDocument().apply {
            append("fieldNull", BsonNull())
            append("list", BsonArray().apply {
                add(BsonString("v1"))
                add(BsonNull())
                add(BsonNull())
                add(BsonString("v4"))
            })
            append("map", BsonDocument().apply {
                append("k1", BsonNull())
                append("k2", BsonInt32(42))
                append("k3", BsonInt32(44))
            })
        }.toByteArray()

        val collection = NullableCollection(
            null,
            listOf("v1", null, null, "v4"),
            mapOf("k1" to null, "k2" to 42, "k3" to 44)
        )

        assertEquals(collection, kBson.load(NullableCollection.serializer(), expected))
    }

    @Test
    fun loadExceptionsMissingValue() {
        val docBadType = BsonDocument().apply {
            append("f1", BsonInt32(1))
            append("f2", BsonInt32(2))
            append("f3", BsonInt32(3))
        }

        try {
            kBson.load(SimpleNG.serializer(), docBadType)
        } catch (e: SerializationException) {
            assertTrue(e.message == "Field 'short' is required, but it was missing")
        }
    }

    @Test
    fun loadExceptionsBadType() {
        val docBadType = BsonDocument().apply {
            put("short", BsonString("127"))
        }

        try {
            kBson.load(SimpleNG.serializer(), docBadType)
        } catch (e: BsonInvalidOperationException) {
            assertTrue(e.message == "readInt32 can only be called when CurrentBSONType is INT32, not when CurrentBSONType is STRING.")
        }
    }

    @Test
    fun stringifyPolymorphism() {
        val pModule = SerializersModule {
            polymorphic(Message::class, StringMessage::class, StringMessage.serializer())
            polymorphic(Message::class, IntMessage::class, IntMessage.serializer())
        }
        val conf = Configuration()
        val mDoc = BsonDocument().apply {
            append("m", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.StringMessage"))
                append("msg", BsonString("FortyTwo"))
            })
        }

        val nDoc = BsonDocument().apply {
            append("m", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.IntMessage"))
                append("number", BsonInt32(42))
            })
        }

        val polyBson = KBson(serializersModule = DefaultModule + pModule)
        val res1 = polyBson.stringify(MessageWrapper.serializer(), MessageWrapper(m = StringMessage("FortyTwo")))
        val res2 = polyBson.stringify(MessageWrapper.serializer(), MessageWrapper(m = IntMessage(42)))

        assertEquals(res1, mDoc)
        assertEquals(res2, nDoc)
    }

    @Test
    fun parsePolymorphism() {
        val pModule = SerializersModule {
            polymorphic(Message::class, StringMessage::class, StringMessage.serializer())
            polymorphic(Message::class, IntMessage::class, IntMessage.serializer())
        }

        val sDoc = BsonDocument().apply {
            append("m", BsonDocument().apply {
                append(
                    Configuration().classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.StringMessage")
                )
                append("msg", BsonString("FortyTwo"))
            })
        }

        val nDoc = BsonDocument().apply {
            append("m", BsonDocument().apply {
                append(
                    Configuration().classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.IntMessage")
                )
                append("number", BsonInt32(42))
            })
        }

        val polyBson = KBson(serializersModule = DefaultModule + pModule)
        val res1 = polyBson.parse(MessageWrapper.serializer(), sDoc)
        val res2 = polyBson.parse(MessageWrapper.serializer(), nDoc)

        assertEquals(MessageWrapper(m = StringMessage("FortyTwo")), res1)
        assertEquals(MessageWrapper(m = IntMessage(42)), res2)
    }

    @Test
    fun stringifyPolymorphismComplexHierarchies() {
        val pModule = SerializersModule {
            polymorphic(Message::class) {
                polymorphic(TimestampedMessage::class) {
                    subclass(FooTimestampedMessage::class, FooTimestampedMessage.serializer())
                    subclass(StringMessage::class, StringMessage.serializer())
                    subclass(IntMessage::class, IntMessage.serializer())
                }
            }
        }
        val conf = Configuration()
        val mDoc = BsonDocument().apply {
            append("request", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.StringMessage"))
                append("msg", BsonString("FortyTwo"))
            })
            append("response", BsonDocument().apply {
                append(
                    conf.classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.FooTimestampedMessage")
                )
                append("timestamp", BsonInt32(1570459730))
            })
        }

        val nDoc = BsonDocument().apply {
            append("request", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.IntMessage"))
                append("number", BsonInt32(42))
            })
            append("response", BsonDocument().apply {
                append(
                    conf.classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.FooTimestampedMessage")
                )
                append("timestamp", BsonInt32(1570459730))
            })
        }

        val polyBson = KBson(serializersModule = DefaultModule + pModule)
        val res1 = polyBson.stringify(
            Wrapper.serializer(), Wrapper(
                request = StringMessage("FortyTwo"),
                response = FooTimestampedMessage(1570459730)
            )
        )
        val res2 = polyBson.stringify(
            Wrapper.serializer(), Wrapper(
                request = IntMessage(42),
                response = FooTimestampedMessage(1570459730)
            )
        )

        assertEquals(res1, mDoc)
        assertEquals(res2, nDoc)
    }

    @Test
    fun parsePolymorphismComplexHierarchies() {
        val pModule = SerializersModule {
            polymorphic(Message::class) {
                polymorphic(TimestampedMessage::class) {
                    subclass(FooTimestampedMessage::class, FooTimestampedMessage.serializer())
                    subclass(StringMessage::class, StringMessage.serializer())
                    subclass(IntMessage::class, IntMessage.serializer())
                }
            }
        }
        val conf = Configuration()
        val mDoc = BsonDocument().apply {
            append("request", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.StringMessage"))
                append("msg", BsonString("FortyTwo"))
            })
            append("response", BsonDocument().apply {
                append(
                    conf.classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.FooTimestampedMessage")
                )
                append("timestamp", BsonInt32(1570459730))
            })
        }

        val nDoc = BsonDocument().apply {
            append("request", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.IntMessage"))
                append("number", BsonInt32(42))
            })
            append("response", BsonDocument().apply {
                append(
                    conf.classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.FooTimestampedMessage")
                )
                append("timestamp", BsonInt32(1570459730))
            })
        }

        val polyBson = KBson(serializersModule = DefaultModule + pModule)

        val res1 = polyBson.parse(Wrapper.serializer(), mDoc)
        val res2 = polyBson.parse(Wrapper.serializer(), nDoc)

        assertEquals(
            Wrapper(
                request = StringMessage("FortyTwo"),
                response = FooTimestampedMessage(1570459730)
            ), res1
        )

        assertEquals(
            Wrapper(
                request = IntMessage(42),
                response = FooTimestampedMessage(1570459730)
            ), res2
        )
    }

    @Test
    fun stringifyPolymorphismSealed() {

        val pModule = SerializersModule {
            polymorphic(SMessage::class) {
                subclass(SMessage.Error.serializer())
                subclass(SMessage.Loading.serializer())
                subclass(SMessage.Data.serializer())
            }
        }
        val conf = Configuration()

        val doc1 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Error"))
            })
        }

        val doc2 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append(
                    conf.classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Loading")
                )
            })
        }

        val doc3 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Data"))
                append("someData", BsonString("something"))
            })
        }

        val polyBson = KBson(serializersModule = DefaultModule + pModule)

        val res1 = polyBson.stringify(
            SealedWrapper.serializer(),
            SealedWrapper(
                payload = SMessage.Error
            )
        )

        val res2 = polyBson.stringify(
            SealedWrapper.serializer(),
            SealedWrapper(
                payload = SMessage.Loading
            )
        )

        val res3 = polyBson.stringify(
            SealedWrapper.serializer(),
            SealedWrapper(
                payload = SMessage.Data(someData = "something")
            )
        )

        assertEquals(res1, doc1)
        assertEquals(res2, doc2)
        assertEquals(res3, doc3)
    }

    @Test
    fun parsePolymorphismSealed() {
        val pModule = SerializersModule {
            polymorphic(SMessage::class) {
                subclass(SMessage.Error::class, SMessage.Error.serializer())
                subclass(SMessage.Loading::class, SMessage.Loading.serializer())
                subclass(SMessage.Data::class, SMessage.Data.serializer())
                subclass(SMessage.DataWithId::class, SMessage.DataWithId.serializer())
                subclass(SMessage.DataWithObjectId::class, SMessage.DataWithObjectId.serializer())
            }
        }
        val conf = Configuration()


        val doc1 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                //simulate an _id field first (loaded from mongo)
                append("_id", BsonObjectId())
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Error"))
            })
        }

        val doc2 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append(
                    conf.classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Loading")
                )
            })
        }

        val doc3 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Data"))
                append("someData", BsonString("something"))
            })
        }

        val doc4 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append("_id", BsonString("5d1777814e8c7b408a6ada73"))
                append(
                    conf.classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.SMessage.DataWithId")
                )
                append("someData", BsonString("something"))
            })
        }

        val doc5 = BsonDocument().apply {
            append("payload", BsonDocument().apply {
                append("_id", BsonObjectId(ObjectId("5d1777814e8c7b408a6ada73")))
                append(
                    conf.classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.SMessage.DataWithObjectId")
                )
                append("someData", BsonString("something"))
            })
        }

        val polyBson = KBson(serializersModule = DefaultModule + pModule)

        val res1 = polyBson.parse(SealedWrapper.serializer(), doc1)

        val res2 = polyBson.parse(SealedWrapper.serializer(), doc2)

        val res3 = polyBson.parse(SealedWrapper.serializer(), doc3)

        val res4 = polyBson.parse(SealedWrapper.serializer(), doc4)

        val res5 = polyBson.parse(SealedWrapper.serializer(), doc5)

        assertTrue(res1.payload is SMessage.Error)
        assertTrue(res2.payload is SMessage.Loading)
        assertEquals(SealedWrapper(SMessage.Data(someData = "something")), res3)
        assertEquals(SealedWrapper(SMessage.DataWithId(someData = "something", _id = "5d1777814e8c7b408a6ada73")), res4)
        assertEquals(
            SealedWrapper(
                SMessage.DataWithObjectId(
                    someData = "something",
                    _id = ObjectId("5d1777814e8c7b408a6ada73")
                )
            ), res5
        )
    }

    @Test
    fun parseDirectPolymorphism() {
        val pModule = SerializersModule {
            polymorphic(SMessage::class) {
                subclass(SMessage.Error::class)
                subclass(SMessage.Loading::class)
                subclass(SMessage.Data::class)
                subclass(SMessage.DataWithId::class)
                subclass(SMessage.DataWithObjectId::class)
            }
        }
        val conf = Configuration()


        val doc1 = BsonDocument().apply {
                //simulate an _id field first (loaded from mongo)
                append("_id", BsonObjectId())
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Error"))
        }

        val doc2 = BsonDocument().apply {
                append(
                    conf.classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Loading")
                )
        }

        val doc3 = BsonDocument().apply {
                append(conf.classDiscriminator, BsonString("com.github.jershell.kbson.models.polymorph.SMessage.Data"))
                append("someData", BsonString("something"))
        }

        val doc4 = BsonDocument().apply {
                append("_id", BsonString("5d1777814e8c7b408a6ada73"))
                append(
                    conf.classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.SMessage.DataWithId")
                )
                append("someData", BsonString("something"))
        }

        val doc5 = BsonDocument().apply {
                append("_id", BsonObjectId(ObjectId("5d1777814e8c7b408a6ada73")))
                append(
                    conf.classDiscriminator,
                    BsonString("com.github.jershell.kbson.models.polymorph.SMessage.DataWithObjectId")
                )
                append("someData", BsonString("something"))
        }

        val polyBson = KBson(serializersModule = DefaultModule + pModule)

        val res1 = polyBson.parse(PolymorphicSerializer(SMessage::class), doc1)

        val res2 = polyBson.parse(PolymorphicSerializer(SMessage::class), doc2)

        val res3 = polyBson.parse(PolymorphicSerializer(SMessage::class), doc3)

        val res4 = polyBson.parse(PolymorphicSerializer(SMessage::class), doc4)

        val res5 = polyBson.parse(PolymorphicSerializer(SMessage::class), doc5)

        assertTrue(res1 is SMessage.Error)
        assertTrue(res2 is SMessage.Loading)
        assertEquals(SMessage.Data(someData = "something"), res3)
        assertEquals(SMessage.DataWithId(someData = "something", _id = "5d1777814e8c7b408a6ada73"), res4)
        assertEquals(
                SMessage.DataWithObjectId(
                    someData = "something",
                    _id = ObjectId("5d1777814e8c7b408a6ada73")
                ),
            res5
        )
    }


    @Test
    fun parseSimpleSetOfStrings() {
        val doc = BsonDocument().apply {
            put("littleSet", BsonArray().apply {
                add(BsonString("one"))
                add(BsonString("two"))
                add(BsonString("three"))
            })
        }

        val result = kBson.parse(WrapperSet.serializer(), doc)

        assertEquals(WrapperSet(setOf("one", "two", "three")), result)
    }

    @Test
    fun stringifySimpleSetOfStrings() {
        val doc = BsonDocument().apply {
            put("littleSet", BsonArray().apply {
                add(BsonString("one"))
                add(BsonString("two"))
                add(BsonString("three"))
            })
        }

        val result = kBson.stringify(
            WrapperSet.serializer(),
            WrapperSet(setOf("one", "two", "three"))
        )

        assertEquals(doc, result)
    }

    @Test
    fun stringifyMapWithObjectIdKeys() {
        val doc = BsonDocument().apply {
            put("elements", BsonDocument().apply {
                put("5d1777814e8c7b408a6ada73", BsonString("one"))
                put("5d1777d04e8c7b408a6ada8a", BsonString("two"))
                put("5d17ab793b4083d41f829821", BsonString("three"))
            })
        }

        val result = kBson.stringify(
            WrapperMapWithObjectId.serializer(), WrapperMapWithObjectId(
                mapOf(
                    ObjectId("5d1777814e8c7b408a6ada73") to "one",
                    ObjectId("5d1777d04e8c7b408a6ada8a") to "two",
                    ObjectId("5d17ab793b4083d41f829821") to "three"
                )
            )
        )

        assertEquals(doc, result)
    }

    @Test
    fun parseMapWithObjectIdKeys() {
        val doc = BsonDocument().apply {
            put("elements", BsonDocument().apply {
                put("5d1777814e8c7b408a6ada73", BsonString("one"))
                put("5d1777d04e8c7b408a6ada8a", BsonString("two"))
                put("5d17ab793b4083d41f829821", BsonString("three"))
            })
        }

        val result = kBson.parse(WrapperMapWithObjectId.serializer(), doc)

        assertEquals(
            result, WrapperMapWithObjectId(
                mapOf(
                    ObjectId("5d1777814e8c7b408a6ada73") to "one",
                    ObjectId("5d1777d04e8c7b408a6ada8a") to "two",
                    ObjectId("5d17ab793b4083d41f829821") to "three"
                )
            )
        )
    }

    @Test
    fun stringifyMapWithAdvancedKeys() {

        val datePoint = Date.from(Instant.parse("2040-12-12T10:21:12Z"))

        val result = kBson.stringify(
            WrapperMapWithAdvancedKey.serializer(),
            WrapperMapWithAdvancedKey(
                mapOf(datePoint to "point"),
                mapOf(BigDecimal("3.14159265") to "PI")
            )
        )

        val doc = BsonDocument().apply {
            put("itemsDate", BsonDocument().apply {
                put(datePoint.time.toString(), BsonString("point"))
            })
            put("itemsBigDecimal", BsonDocument().apply {
                put("3.14159265", BsonString("PI"))
            })
        }

        assertEquals(doc, result)
    }

    @Test
    fun parseMapWithWithAdvancedKeys() {

        val datePoint = Date.from(Instant.parse("2040-12-12T10:21:12Z"))

        val doc = BsonDocument().apply {
            put("itemsDate", BsonDocument().apply {
                put(datePoint.time.toString(), BsonString("point"))
            })
            put("itemsBigDecimal", BsonDocument().apply {
                put("3.14159265", BsonString("PI"))
            })
        }

        val result = kBson.parse(WrapperMapWithAdvancedKey.serializer(), doc)

        assertEquals(
            WrapperMapWithAdvancedKey(
                mapOf(datePoint to "point"),
                mapOf(BigDecimal("3.14159265") to "PI")
            ), result
        )
    }

    @Test
    fun parseMaps() {
        val foo = Foo(
            key_A = mapOf(
                "key_0" to "value_0",
                "key_1" to "value_1",
                "key_2" to "value_2",
                "key_3" to "value_3",
                "key_4" to "value_4"
            ),
            key_B = mapOf(
                "a" to "a2",
                "b" to "b2",
                "c" to "c2",
                "d" to "d2",
                "e" to "e2"
            )
        )

        val doc = BsonDocument().apply {
            put("key_A", BsonDocument().apply {
                put("key_0", BsonString("value_0"))
                put("key_1", BsonString("value_1"))
                put("key_2", BsonString("value_2"))
                put("key_3", BsonString("value_3"))
                put("key_4", BsonString("value_4"))
            })
            put("key_B", BsonDocument().apply {
                put("a", BsonString("a2"))
                put("b", BsonString("b2"))
                put("c", BsonString("c2"))
                put("d", BsonString("d2"))
                put("e", BsonString("e2"))
            })
        }
        val result = kBson.parse(Foo.serializer(), doc)
        assertEquals(foo, result)
    }

    @Test
    fun stringifyUUID() {
        val uuuid1 = UUID.randomUUID()
        val uuuid2 = UUID.randomUUID()
        val uuuid3 = UUID.randomUUID()

        val uuidRepresentation: UuidRepresentation = UuidRepresentation.STANDARD

        val document = BsonDocument().apply {
            append("uuid", BsonBinary(uuuid1, uuidRepresentation))
            append("map", BsonDocument().apply {
                append(uuuid2.toString(), BsonBinary(uuuid3, uuidRepresentation))
            })
        }
        val result = kBson.stringify(WithUUID.serializer(), WithUUID(uuuid1, mapOf(uuuid2.toString() to uuuid3)))

        assertEquals(document, result)
    }

    @Test
    fun parseUUID() {
        val uuuid1 = UUID.randomUUID()
        val uuuid2 = UUID.randomUUID()
        val uuuid3 = UUID.randomUUID()

        val uuidRepresentation: UuidRepresentation = UuidRepresentation.STANDARD

        val document = BsonDocument().apply {
            append("uuid", BsonBinary(uuuid1, uuidRepresentation))
            append("map", BsonDocument().apply {
                append(uuuid2.toString(), BsonBinary(uuuid3, uuidRepresentation))
            })
        }

        val result = kBson.parse(WithUUID.serializer(), document)

        assertEquals(WithUUID(uuuid1, mapOf(uuuid2.toString() to uuuid3)), result)

    }

    @Test
    fun stringifyMApKeyEnum() {
        val doc = BsonDocument().apply {
            append("map", BsonDocument().apply {
                append("FEMALE", BsonInt32(234))
                append("MALE", BsonInt32(231))
                append("TRANSGENDER", BsonInt32(235))
            })
        }

        KeyByEnum(mapOf(SEX.FEMALE to 234, SEX.MALE to 231, SEX.TRANSGENDER to 235))
            .let {
                kBson.stringify(KeyByEnum.serializer(), it)
            }
            .let {
                assertEquals(doc, it)
            }
    }
}
